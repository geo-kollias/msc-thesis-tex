For understanding better what declosurify does let's see how List(1, 2, 3).map(_
+ 1) \fxfatal{code format} is translated from both scalac and declosurify.
List(1, 2, 3).map(_ + 1) is a shortcut for List(1, 2, 3).map(x => x + 1), where
x => x + 1 is an anonymous function that increments its argument by one.
Applying that function to the List(1, 2, 3) will result to a new list List(2,
3, 4). Since Scala code is translated into Java bytecode at the end and, since,
Java  doesn't support any notion of function inherently, at least until Java 7,
this anonymous function should be translated somehow in constructs that are
supported from Java bytecode. So below we see how scalac translates the
internally the trivial Scala program below:\\
\fxfatal{src code} \\
%package src.main.scala
% object ListMapCompilation extends App {
%   List(1, 2, 3).map(_ + 1)
% }

\fxfatal{scalac traslated code}
% package src.main.scala {
%   object ListMapCompilation extends Object with App {
%     def <init>(): src.main.scala.ListMapCompilation.type = {
%       ListMapCompilation.super.<init>();
%       ()
%     };
%     immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1,
% 2, 3})).map[Int, List[Int]]({
%       @SerialVersionUID(0) final <synthetic> class $anonfun extends
% scala.runtime.AbstractFunction1[Int,Int] with Serializable {
%         def <init>(): anonymous class $anonfun = {
%           $anonfun.super.<init>();
%           ()
%         };
%         final def apply(x$1: Int): Int = x$1.+(1)
%       };
%       (new anonymous class $anonfun(): Int => Int)
%     }, immutable.this.List.canBuildFrom[Int]())
%   }
% }

We can see that scalac converts the _ + 1 function into a block of code (code
between two braces), where a class, called \$anonfun, is defined. That class
extends the AbstractFunction1[Int,Int] class, which is an abstract
class that represents the functions that take one integer argument and return
another integer. Inside the class an apply method is defined which is called
whenever we apply the class' objects to one integer argument. The apply's body
returns  its argument incremented by one,  e.g., val a1 = new \$anonfun();
a1(5); returns 6. Just after the class definition scalac creates a new object
of this class and it's what actually returned from that block of code.
Eventually the _ + 1 is substituted with an object of a subclass of a class
representing functions internally, which leads us to the conclusion that the
scala source-level closures are translated to function objects. Below we attach
the basic map implementation in the standard Scala library:

def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That =
{
    def builder = {
      val b = bf(repr)
      b.sizeHint(this)
      b
    }
    val b = builder
    for (x <- this) b += f(x)
    b.result
}

Here f is the function object scalac passed during the map call. f(x) is a
normal method call on object f and it will be expanded to f.apply(x). We can
easily see that f's runtime type will, usually, be different on each map call
since the functions we pass are generally different. Such calls are called
mega-morphic virtual calls and, currently, are not inlined from the JVM. So on
each map we generally have the added overhead of a dynamic call to the passed
function object. It's a relatively new problem that came up along with the 
