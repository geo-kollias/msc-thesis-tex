For understanding better what declosurify does let's see how List(1, 2, 3).map(_
+ 1) \fxfatal{code format} is translated from both scalac and declosurify.
List(1, 2, 3).map(_ + 1) is a shortcut for List(1, 2, 3).map(x => x + 1), where
x => x + 1 is an anonymous function that increments its argument by one.
Applying that function to the List(1, 2, 3) will result to a new list List(2,
3, 4). Since Scala code is translated into Java bytecode at the end and, since,
Java  doesn't support any notion of function inherently, at least until Java 7,
this anonymous function should be translated somehow in constructs that are
supported from Java bytecode. So below we see how scalac translates the
internally the trivial Scala program below:\\

package src.main.scala

object ListMapCompilation extends App {
  List(1, 2, 3).map(_ + 1)
}

package src.main.scala {
  object ListMapCompilation extends Object with App {
    def <init>(): src.main.scala.ListMapCompilation.type = {
      ListMapCompilation.super.<init>();
      ()
    };
    immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1,
2, 3})).map[Int, List[Int]]({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends
scala.runtime.AbstractFunction1[Int,Int] with Serializable {
        def <init>(): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x$1: Int): Int = x$1.+(1)
      };
      (new anonymous class $anonfun(): Int => Int)
    }, immutable.this.List.canBuildFrom[Int]())
  }
}
