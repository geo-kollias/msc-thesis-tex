Section: What declosurify does

For understanding better what declosurify does let's see how List(1, 2, 3).map(_
+ 1) \fxfatal{code format} is translated from both scalac and declosurify point
of views. List(1, 2, 3).map(_ + 1) is a shortcut for List(1, 2, 3).map(x => x +
1), where x => x + 1 is an anonymous function that returns its
argument incremented by one.
Applying that function to the List(1, 2, 3) will result to a new list List(2,
3, 4). Since Scala code is translated into Java bytecode at the end and, since,
Java  doesn't support any notion of function inherently, at least up to Java 7,
this anonymous function should be translated somehow in constructs that are
supported from Java bytecode. So below we see how scalac translates the trivial
Scala program internally:\\
\fxfatal{src code} \\
% package src.main.scala
% object ListMapCompilation extends App {
%   def f = List(1, 2, 3).map(_ + 1)
% }

\fxfatal{scalac traslated code}
% package src.main.scala {
%   object ListMapCompilation extends Object with App {
%     def <init>(): src.main.scala.ListMapCompilation.type = {
%       ListMapCompilation.super.<init>();
%       ()
%     };
%     def f(): List[Int] =
% immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2,
% 3})).map[Int, List[Int]]({
%       @SerialVersionUID(0) final <synthetic> class $anonfun extends
% scala.runtime.AbstractFunction1[Int,Int] with Serializable {
%         def <init>(): anonymous class $anonfun = {
%           $anonfun.super.<init>();
%           ()
%         };
%         final def apply(x$1: Int): Int = x$1.+(1)
%       };
%       (new anonymous class $anonfun(): Int => Int)
%     }, immutable.this.List.canBuildFrom[Int]())
%   }
% }


We can see that scalac converts the _ + 1 function into a block of code
(piece of code between two braces), where a class, called \$anonfun, is defined.
That class
extends the AbstractFunction1[Int,Int] class, which is an abstract
class that represents the functions that take one integer argument and return
another integer. Inside the class an apply method is defined which is called
whenever we apply a class' object to one integer argument. The apply's body
returns  its argument incremented by one,  e.g., val a1 = new \$anonfun();
a1(5); returns 6. Just after the class definition scalac creates a new object
of this class and it's what actually returned from that block of code.
Eventually the _ + 1 is substituted with an object of a subclass of a class
representing functions internally, which leads us to the conclusion that the
scala source-level closures are translated to function class objects. Below we
attach the basic map implementation in the standard Scala library:

def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That =
{
    def builder = {
      val b = bf(repr)
      b.sizeHint(this)
      b
    }
    val b = builder
    for (x <- this) b += f(x)
    b.result
}

Here f is the function object scalac passed during the map call, i.e. the
object resulted from new \$anonfun() above. f(x) is a
normal method call on object f and it will be expanded to f.apply(x). We can
easily see that f's runtime type will, usually, be different on each map call
since the functions we pass are generally different. Such calls are called
mega-morphic virtual calls and, currently, are not inlined from the JVM as we
exlained in the previous chapter. So on
each map we generally have the added overhead of a dynamic call to the passed
function object. Even worse, the lack of knowledge of what goes on inside the
virtual call prevents all kinds of crucial optimizations such as loop unrolling,
range-check elimination and all kinds of prefetching and alias analyses.

Let's see how declosurify translates a very similar piece of code:

% package src.main.scala
% object ListMapCompilation extends App {
%   def f = List(1, 2, 3).macroMap(_ + 1)
% }

The only difference here is the use of macroMap instead of the plain map. It's
translated into:

% package src.main.scala {
%   object ListMapCompilation extends Object with App {
%     def <init>(): src.main.scala.ListMapCompilation.type = {
%       ListMapCompilation.super.<init>();
%       ()
%     };
%     def f(): List[Int] = {
%       private def local1(x$1: Int): Int = x$1.+(1);
%       val buf: scala.collection.mutable.Builder[Int,List[Int]] =
% newBuilder[Int]();
%       var these: List[Int] =
% immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2,
% 3}));
%       while(these.isEmpty().unary_!()){
%         buf.+=(local1(these.head()));
%         these = these.tail()
%       };
%       buf.result()
%     }
%   }
% }

Here we see that there is no explicit call to any map method. Instead the
list's traveral happens directly within a while loop where the local1 local free
method is applied to all list's elements. The local1 method is called a free
method since it's not directly attached to any class or object. During the
scalac's ``flatten'' phase, it will be lifted and become a ListMapCompilation's
method with a new mangled name. In particular the code above will become:

% package src.main.scala {
%   object ListMapCompilation extends Object with App {
%     def f(): List = {
%       val buf: collection.mutable.Builder =
% scala.collection.immutable.List.newBuilder();
%       var these: List =
% immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
%      
%       while(these.isEmpty().unary_!()){
%         buf.+=(scala.Int.box(ListMapCompilation.this.local1\$1(
%scala.Int.unbox(these.hea d % ()))));
%         these = these.tail().$asInstanceOf[List]()
%       };
%       buf.result().$asInstanceOf[List]()
%     };
%     final private[this] def local1$1(x$1: Int): Int = x$1.+(1);
%     def <init>(): src.main.scala.ListMapCompilation.type = {
%       ListMapCompilation.super.<init>();
%       ListMapCompilation.this.$asInstanceOf[App$class]()./*App$class*/$init$();
%       ()
%     }
%   }
% }

As we can see now, local1is lifted to local1\$1 and its receiver became
ListMapCompilation.this which will remain unchanged during the program
execution and so it's much easier for JVM to inline the local1\$1 method and
reason about further optimizations.


Section: How declosurify works


Subsection: Putting declosurify functionality in the Scala standard library

Initially declosurify could be used as a library adding the methods macroMap
and macroForeach on all Scala collections that implemented the
scala.collection.TraversableOnce trait and Arrays, through Scala's implicit
conversions. Since, ultimately, we would like to substitute default map and
foreach methods with macroMap and macroForeach respectively, we had to move them
inside the Scala standard library. Scala standard library doesn't have access to
the new compile-time reflection capabilities since it doesn't depend on the
scala-reflect and scala-compiler packages. As a solution, we used the scala
compiler's FastTrack mechanism defined in scala.tools.reflect.FastTrack
trait. Basically, it's a low level mechanism to invoke macro expansions for
builtin macros. One such builtin macro is the reify function itself  we saw in
the previous chapter. FastTrack module uses a registry where you link
method's compiler Symbols with special handler methods. For example, whenever
the compiler sees a Symbol representing a reify's application, it calls its
respective FastTrack special handler which has access to reify appication's
call-site context and all of  its arguments' Abstract Syntax Trees (ASTs),
through pattern matching. Call-site context object, generally, holds call-site
information like the macro application's enclosing method, its enclosing class,
its line in the file. The ASTs contain the internal representation of the macro
application like ``List(1, 2, 3).macroMap(_ + 1)'' i.e., the receiver object,
the macroMap or macroForeach method call and its function argument. The pattern
matching happens upon these ASTs so, theoritically, we can choose to match
successfully against ``List(1,2,3).macroMap(_ + 1)'' but not against ``val r =
List(1,2,3); r.macroMap(_ + 1)'' depending on our needs. If the pattern matching
is successful, its respective compiler handler will eventually generate the AST
which replaces the macro application's AST at the call-site, completing that way
that low-level macro expansion. In our case, whenever scalac finds a Symbol of
an application of the scala.collection.TraversableLike trait's macroMap or
macroForeach method, it triggers the expansion we will describe in the next
subsection.

Regular Scala macros implementations can be generic in the sense that they can
be customized with type parameters as any regular Scala method. On top of that,
Scala compiler allows you to ``tag'' each of these type parameters with special
compiler-generated objects, of type (Weak)TypeTag [cite], that store the type
parameters' full types on each call and make them available at runtime. In
short, it's the Scala's solution against JVM's type erasure. This machinery is
especially useful for macros, since you can inspect these TypeTag objects and
generate the most suitable code for each occasion. Unfortunately, using the low
level compiler's FastTrack mechanism doesn't permit using this facility.
Instead, we are forced to work directly with the compiler's internal type
representations lowering the level of abstraction we can work with.

FastTrack's special handler for the macroMap/macroForeach methods, after
doing some preprocessing on the pattern matched ASTs, will call the metod
that does the actual transformation we saw in the previous subsection. Firstly,
let's see this method's signature and what arguments it obtains
from the handler.

This method is defined in scala.tools.reflect.declosurify.Declosurify
object ``def mapInfix[A, B](c0: Ctx)(f0: c0.Expr[A => B], inElemTpe: c0.Type,
outElemTpe: c0.Type, inCollTpe: c0.Type, outCollTpe: c0.Type, bfTree: c0.Tree):
c0.Tree''. Despite its name, mapInfix can generate code for both macroMap and
macroForeach. It's a curried method parameterized on the received function's
input and return types (A, B). In the first parameter list, c0 is a context
object as we described it above, giving us access to macro application's
call-site information. In the second parameter list, f0 represents a typed 

c0.Expr realizes the notion of Scala's path-depedent types. Here we  choose the
Expr that it's defined inside the c0 object. The same holds for the c0.Type
that follow.