Section: What ft-declosurify does

For understanding better what ft-declosurify does let's see how List(1, 2,
3).map(_ + 1) is translated from both scalac and ft-declosurify point
of views. List(1, 2, 3).map(_ + 1) is a shortcut for List(1, 2, 3).map(x => x +
1), where x => x + 1 is an anonymous function -closure- that returns its
argument incremented by one.
Applying that function to the List(1, 2, 3) will result to a new list List(2,
3, 4). Since Scala code is translated into Java bytecode at the end and, since,
Java  doesn't support any notion of functions inherently, at least up to Java 7,
this anonymous function should be translated somehow in constructs that are
supported by the Java bytecode. The trivial Scala program below:

package src.main.scala
object ListMapCompilation extends App {
  def f = List(1, 2, 3).map(_ + 1)
}

is translated internally by scalac to:

package src.main.scala {
  object ListMapCompilation extends Object with App {
    def <init>(): src.main.scala.ListMapCompilation.type = {
      ListMapCompilation.super.<init>();
      ()
    };
    def f(): List[Int] =
immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2,
3})).map[Int, List[Int]]({
      @SerialVersionUID(0) final <synthetic> class $anonfun extends
scala.runtime.AbstractFunction1[Int,Int] with Serializable {
        def <init>(): anonymous class $anonfun = {
          $anonfun.super.<init>();
          ()
        };
        final def apply(x$1: Int): Int = x$1.+(1)
      };
      (new anonymous class $anonfun(): Int => Int)
    }, immutable.this.List.canBuildFrom[Int]())
  }
}


We can see that scalac converts the _ + 1 function into a block of code
(piece of code between two braces), where a class, called $anonfun, is defined.
That class extends the AbstractFunction1[Int,Int] class, which is an abstract
class that represents the functions that take one integer argument and return
another integer. Inside the class an apply method is defined which is called
whenever we apply a class' object to one integer argument. The apply's body
returns  its argument incremented by one,  e.g., val a1 = new $anonfun();
a1(5); returns 6. Just after the class definition scalac creates a new object
of this class and it's what actually returned from that block of code.
Eventually, the _ + 1 is substituted with an object of a subclass of a class
representing functions internally, which leads us to the conclusion that the
scala source-level closures are translated to function class objects. Below we
attach the basic map implementation in the standard Scala library:

def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That =
{
    def builder = {
      val b = bf(repr)
      b.sizeHint(this)
      b
    }
    val b = builder
    for (x <- this) b += f(x)
    b.result
}

Here f is the function object scalac passed during the map call, i.e., the
object resulted from new $anonfun() above. f(x) is a
normal method call on object f and it will be expanded to f.apply(x). We can
easily see that f's runtime type will, usually, be different on each map call
since the functions we pass are generally different. Such calls are called
mega-morphic virtual calls and, currently, are not inlined from the JVM as we
exlained in the previous chapter. So on
each map we generally have the added overhead of a dynamic call to the passed
function object. Even worse, the lack of knowledge of what goes on inside the
virtual call prevents all kinds of crucial optimizations.

Let's see how ft-declosurify translates a very similar piece of code:

package src.main.scala
object ListMapCompilation extends App {
  def f = List(1, 2, 3).macroMap(_ + 1)
}

The only difference here is the use of macroMap instead of the plain map. It's
translated into:

package src.main.scala {
  object ListMapCompilation extends Object with App {
    def <init>(): src.main.scala.ListMapCompilation.type = {
      ListMapCompilation.super.<init>();
      ()
    };
    def f(): List[Int] = {
      private def local1(x$1: Int): Int = x$1.+(1);
      val buf: scala.collection.mutable.Builder[Int,List[Int]] =
newBuilder[Int]();
      var these: List[Int] =
immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2,
3}));
      while(these.isEmpty().unary_!()){
        buf.+=(local1(these.head()));
        these = these.tail()
      };
      buf.result()
    }
  }
}

Here we see that there is no explicit call to any map method. Instead the
list's traveral happens directly within a while loop where the local1 local free
method is applied to all list's elements. The local1 method is called a free
method since it's not directly attached to any class or object. During the
scalac's ``flatten'' phase, it will be lifted and become a ListMapCompilation's
method with a new mangled name. In particular the code above will become:

package src.main.scala {
  object ListMapCompilation extends Object with App {
    def f(): List = {
      val buf: collection.mutable.Builder =
scala.collection.immutable.List.newBuilder();
      var these: List =
immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
     
      while(these.isEmpty().unary_!()){
        buf.+=(scala.Int.box(ListMapCompilation.this.local1\$1(
scala.Int.unbox(these.hea d % ()))));
        these = these.tail().$asInstanceOf[List]()
      };
      buf.result().$asInstanceOf[List]()
    };
    final private[this] def local1$1(x$1: Int): Int = x$1.+(1);
    def <init>(): src.main.scala.ListMapCompilation.type = {
      ListMapCompilation.super.<init>();
      ListMapCompilation.this.$asInstanceOf[App$class]()./*App$class*/$init$();
      ()
    }
  }
}

As we can see now, local1is lifted to local1\$1 and its receiver became
ListMapCompilation.this which will remain unchanged during the program
execution and so it's much easier for JVM to inline the local1$1 method and
reason about further optimizations.


Section: How ft-declosurify works


Subsection: Putting ft-declosurify functionality in the Scala standard library

ft-declosurify is based on the  Paul Phillips's declosurify project {cite}. The
ft prefix stands for fast-track and we will explain here what it
means and how they differ. Initially, declosurify could be used as a library
adding the -extension- methods macroMap and macroForeach on all Scala
collections that implemented the scala.collection.TraversableOnce trait and
Arrays, through Scala's implicit conversions {cite implicit conversions}. Since,
ultimately, we would like to substitute the default map and foreach methods
with the macroMap and macroForeach implementations respectively, we had to move
them inside the Scala standard library. Because the implementation for macroMap
and macroForeach is mostly the same, from now on we will be referring mainly to
the macroMap implementation without loss of generality. Scala standard library
doesn't have access to the new compile-time reflection capabilities since it
doesn't depend on the
scala-reflect and scala-compiler packages, so we can't have definition like
``def m(x: T): R = macro implRef'' in it. As a solution, we
used the scala
compiler's FastTrack mechanism defined in scala.tools.reflect.FastTrack
trait. Basically, it's a low level mechanism to invoke macro expansions for
builtin macros. One such builtin macro is the reify function itself  we saw in
the previous chapter. FastTrack module uses a registry where you link
method's compiler Symbols with special handler methods. For example, whenever
the compiler sees a Symbol representing a reify's application, it calls its
respective FastTrack special handler which has access to reify appication's
call-site context and all of  its arguments' Abstract Syntax Trees (ASTs),
through pattern matching. Call-site context object, generally, holds call-site
information like the macro application's enclosing method, its enclosing class,
its line in the file. The ASTs contain the internal representation of the macro
application like ``List(1, 2, 3).macroMap(_ + 1)'' i.e., the receiver object,
the macroMap method call and its function argument. The pattern
matching happens upon these ASTs so, theoritically, we can choose to match
successfully against ``List(1,2,3).macroMap(_ + 1)'' but not against ``val r =
List(1,2,3); r.macroMap(_ + 1)'' depending on our needs. If the pattern matching
is successful, its respective compiler handler will eventually generate the AST
which replaces the macro application's AST in the call-site, completing that way
that low-level macro expansion. In our case, whenever scalac finds a Symbol of
an application of the scala.collection.TraversableLike trait's macroMap
method, it triggers the expansion we will describe in the next
subsection.

Regular Scala macros implementations can be generic in the sense that they can
be customized with type parameters as any regular Scala method. On top of that,
Scala compiler allows you to ``tag'' each of these type parameters with special
compiler-generated objects, of type (Weak)TypeTag [cite], that store the type
parameters' full types on each call and make them available at runtime. In
short, it's the Scala's solution against JVM's type erasure. This machinery is
especially useful for macros, since you can inspect these TypeTag objects and
generate the most suitable code for each occasion. Unfortunately, using the low
level compiler's FastTrack mechanism doesn't permit using this facility.
Instead, we are forced to work directly with the compiler's internal type
representations lowering the level of abstraction we can work with.

FastTrack's special handler for the macroMap method, after
doing some preprocessing on the pattern matched ASTs, will call the metod
that does the actual transformation we saw in the previous subsection. 


Subsection: Transformation Method Interface

Firstly, let's see the transformation method's signature and what arguments it
obtains from the handler. This method is defined in
scala.tools.reflect.declosurify.Declosurify object ``def mapInfix[A, B](c0:
Ctx)(f0: c0.Expr[A => B], inElemTpe: c0.Type, outElemTpe: c0.Type, inCollTpe:
c0.Type, outCollTpe: c0.Type, bfTree: c0.Tree): c0.Tree''. Despite its name,
mapInfix can generate ASTs for both macroMap and macroForeach. It's a curried
method parameterized on the received function's input (A) and return (B) types.
In the first parameter list, c0 is a context object as we described it above,
giving us access to macro application's call-site information. The most
important c0's field is the ``prefix'' which represents the receiver collection
object of the macroMap application. We will call it simply ``prefix''
from now on. In the second parameter
list, f0 represents the function's AST which is going to be applied to the
prefix. Its type ``Expr'' wraps an AST and an internal type tag
(``TypeTag'') to provide access to the type of the tree. As we mentioned
before, using ``Expr'' doesn't really help us working at that level of the
compiler, since we cannot really exploit the (Weak)TypeTag's facilities. The
next four arguments are:
 - inElemTpe: the internal compiler type of the prefix's elements
 - outElemTpe: the internal compiler type of the elements of the collection our
macroMap
is going to return
- inCollTpe: the internal compiler type of the prefix
- outCollTpe: the internal compiler type of the collection our macroMap is going
to return

The last element is the AST of a scala.collection.generic.CanBuildFrom [cite
adrian moors phd] object that makes easier and more maintable the creation of
new collection out of existing ones. It's used thoroughly through out the
standard library and,
right now, it's not really used in the ft-declosurify so we are not going to
elaborate more on that argument.

It's easy to observe that all of second parameter list types are prepended
with the context object c0. That qualified notation realizes the notion of
Scala's path-depedent types. For example, here we choose the ``Expr'' that it's
defined inside the c0 object. Generally, if we have two different objects c0 and
c1 of the same type which include an inner type MyType, e.g., through type
member or inner class,  then c0.MyType is a different type from c1.MyType in
Scala. The same holds for the ``c0.Type''s that follow.


Subsection: Transformation Requirements

Knowing what our transformation method can operate upon we can examine the
main points of the actual transformation. One of the first things ft-declosurify
checks is if the ``outCollTpe'' is Unit or not (lines XX-YY). If it's Unit then
it means
macro is applied only for its side-effects so it's a foreach call. Instead of
leaning on this heuristic, newer version of the Scala macros provide us with the
exact name of the calling method.

After that, we check three conditions to ensure that a typical
transformation can take place (lines XX-ΥΥ):
- the f0 AST is actually a function AST or a block whose last
expression is a function, since, in Scala, the value of a block is the block's
last expression.
- the f0 AST doesn't contain any return expressions.
- macro application is enclosed in a method. Currently, that limitation makes
the transformation easier.

If any of the above points is not satisfied, then the mapInfix falls back to the
default map/foreach implementation by generating an AST which
calls the map/foreach method on the same prefix object (lines XX-ΥΥ).

The next important step is the transformation of the passed closure AST
into a local free method AST (lines XX-YY). For example, the passed closure ``x
=> x + 1'' would be transformed to ``def local1(x$1: Int): Int = x$1.+(1);''. A
closure like ``x => x + y'' where y is defined in the local scope would be
transformed to something like ``def local1(x: Int): Int =
x.+(TestMacroMapObject.this.y)''. Also, a closure like ``{println(''hi``); x =>
x + 1}'' would be transformed to ``def local1(x: Int): Int = {println(''hi``);
x.+(1)}'


Subsection: Transformations Pattern

Different transformations are applied on different kind of prefixes but all of
them share the same basic structure. In pseudocode that structure could be
described as:

reify {
  val local_method = local_method_AST.splice // we saw it in the previous
subsection
  val inputCollection = prefix_AST.splice
  var outputCollectionBuf = output_collection_buffer_AST.splice // that will
hold or generate the new collection
  while (prefix.has_more_elements()) {
    val elem = prefix.get_next_element()
    val result = local_method(elem)
    outputCollectionBuf.add(result)
  }
  outputCollectionBuf.generate()
}

The reasons we need differrent implementations for different kinds of
prefixes are:
- Each kind has different API, e.g., different supported methods
- Different implementation logic is needed for each kind in order to produce
faster code, by exploiting specific kinds' characteristics.

Here we see how important reifying and splicing operations are. The mentioned
ASTs that we splice inside the reify above are constructed with one of these
three ways depending on the occasion:
- we get them directly from the FastTrack's pattern matching
- we get them by using the ``Symbol''s and ``Type'''s APIs
- we construct them manually.

Whatever AST is returned from the reify will eventually replace the macro
application's AST in the first place.


Subsection: Arrays, ArraysOps and IndexedSeq Transformation

scala.Array and all collections that implement the 
scala.collection.mutable.ArrayOps and scala.colletion.IndexedSeq traits share
the same transformation, since all of them are indexed sequences. The exact
transformation is defined on lines XX-YY. As an example, any macroMap
applications on Arrays like:

Array(1, 2, 3).macroMap(_ + 1)

will be replaced from:

{
  def local1(x$1: Int): Int = x$1.+(1);
  val xs: Array[Int] = scala.this.Predef.intArrayOps(scala.Array.apply(1,
scala.this.Predef.wrapIntArray(Array[Int]{2, 3}))).repr();
  var buf: Array[Int] = new Array[Int](xs.length());
  var i: Int = 0;
  while(i.<(xs.length())){
    buf.update(i, local1(xs.apply(i))); // buf(i) = (local1(r(i)));
    i = i.+(1)
  };
  buf
}

In the next chapter will see how much faster this version is compared to
Array(1, 2, 3).map(_ + 1).


Subsection: LinearSeq Transformation
[Add example with List]


Subsection: Traversable Transformation
[Regards the rest of the Scala collections. Add example with e.g. Vector]
