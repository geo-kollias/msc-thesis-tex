This work describes the implementation of specific Scala collections operations using its recent compile-time metaprogramming capabilities.

Scala [cite] is a relatively new statically typed programming language that tries to unify the object-oriented and functional programming paradigms into one coherent paradigm, recently called object-functional. 

Scala version 2.10, released on [date], introduced a new reflection subsystem adding both compile and run time metaprogramming capabilities. The new run-time reflection is much more general and feature complete compared to the Java's reflection. Compile-time reflection is quite rare and, currently, it can be found only in more exotic functional languages like Haskell [cite Template Haskell] and ML [cite Meta-ML]. Compile-time reflection enabled the introduction of an experimental version of type-safe  macros \fxwarning{explain the concept in the background chapter} which are mostly known in the dynamic functional programming community and especially the Lisp community.

Compile-time reflection capabilities are 

That system enabled the introduction of an experimental version of 

whose main implementation runs on the JVM [cite]. 

The primary motivation for this work was to check if macros can help us create faster collections by inlining operations at the call site. The project is based on Paul Phillips’s declosurify project (github.com/paulp/declosurify) and modifies it to make the functionality available at the standard Scala library level, so that all operations implemented with macros can be used on plain Scala collection types (e.g., List, Array, etc.) without the need of creating new specialized types. Wherever the macro expansion is not feasible or appropriate we can fallback to the default “normal” implementation. Also, the use of macros here is not typical since they are used from inside the Scala Library where no macro detection/expansion functionalities are directly available (the Scala library doesn’t depend on the Scala compiler or Scala reflect packages). The results are encouraging since initial ScalaMeter benchmarks show a 30\% speedup. You can check the project’s progress here github.com/geo-kollias/scala/tree/declosurify.
